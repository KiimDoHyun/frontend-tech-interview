## 목차

-   [프로그래밍 🔥](#프로그래밍)

    -   프로그래밍이란 뭐라고 생각하나요?

        -   해결해야 할 문제를 이해하고, 적절한 문제 해결 방안을 정의한다.
        -   0과 1 밖에 해석하지 못하는 컴퓨터에게 정교한 작업을 지시하는 것이며 이 작업 지시서가 코드다.

    -   컴파일러는 뭐고 인터프리터는 뭔가요? 🔥

사람이 작성한 코드를 컴퓨터가 실행할 수 있도록 기계어로 해석해주는것
컴파일러는 전체 코드를 한번에 변경하고 인터프리터는 한줄씩 해석한다.

컴파일러는 전체 코드를 변경하기 때문에 최종 실행되기 전 타입에러등을 검출하지만
인터프리터는 한줄씩 해석/실행 하기 때문에 오류가 발생한 코드에 도달해야 오류가 발생한다.

-   [자바스크립트란 🔥](#자바스크립트란)

    -   자바스크립트의 특징은 뭐가 있나요?

1. 렉시컬 스코프
   자바스크립트는 함수단위로 실행되는데 함수의 유효범의 즉 접근가능한 변수의 범위는 함수의 소출이 아닌 선언시점에 결정된다.
2. 싱글 스레드 기반
   하나의 스택을 가지고 실행맥락 단위로 쌓인 코드가 한번에 하나씩 실행된다. 따라서 한번에 하나의 작업만 가능하지만 자바스크립트 런타임에의해 생성되는 태스크큐, 마이크로큐, 웹 api, 이벤트루프 등에의해 비동기 작업을 수행할 수 있다.
3. 웹프로그래밍을 위해서 제작된 언어. 브라우저 환경에서만 실행될 수 있는 언어지만 Node.js의 등장으로 웹으로부터 독립적인 환경에서 실행 가능하다.

-   [변수 🔥](#변수)

    -   변수란 무엇인가요?
        -   변할수 있는 데이터
    -   식별자란 무엇인가요? 🔥
        -   데이터를 담을 공간을 식별하는 이름
        -   변수란 변경가능한 데이터가 담길 공간을 의미하고 식별자는 그 공간의 이름을 뜻한다.
    -   변수를 선언한다는 것은 어떤 것을 의미하나요?
        -   데이터를 저장하기위한 메모리 공간을 확보하는것
    -   var 키워드는 뭔가요?
        -   자바스크립트의 변수 선언 키워드
    -   호이스팅이 뭔가요? 🔥🔥

        -   자바스크립트 엔진이 소스코드를 실행하기 전 내부적으로 변수 선언이 먼저 실행되어 해당 스코프 내의 모든 선언문이 마치 최 상단으로 끌어올려진듯한 현상
        -   소스코드의 실행전 실행컨텍스트에 변수를 먼저 등록하기 때문

    -   var 키워드의 문제점은 무엇이 있나요? 🔥
        -   1. 최 상단 범위에서 선언하는 경우 window객체에 변수가 등록된다.
        -   2. 중복 선언이 허용된다.
        -   3. 변수의 유효범위가 함수스코프를 따른다.
    -   let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥
        -   let 키워드는
        -   1. 유효범위가 다르다. 블록 스코프를 따른다.
        -   2. 중복 선언이 불가능하다.
        -   즉, 서로다른 스코프에서 선언된 동일한 이름의 let 변수는 서로 다른 변수다.
    -   TDZ 🔥🔥
        -   호이스팅은 함수가 실행되기전 함수의 실행맥락에 내부의 모든 변수가 선언/초기화 단계를 거치면서 등록되는 것이라 했다. 이때 var 키워드 변수는 선언/초기화 단계를 거치면서 변수가 undefined로 초기화된 메모리를 참초하는 반면, let/const 키워드는 선언 단계만 거치기 때문에 변수를 사용할 준비는 되었으나 어떤 메모리 공간도 참조하지 못한 상태다. 따라서 var 와 다르게 선언 이전에 접근하는 경우 참조에러가 발생한다.
            -   선언: 변수의 존재를 알리는 과정 (식별자)
            -   초기화: 메모리 공간을 확보하고 식별자와 메모리 공간을 연결
    -   const 키워드는 어떤 특징이 있나요? 🔥
        -   한번 초기화된 변수는 재할당이 불가능하기 때문에 상수처럼 사용가능하다.
        -   따라서선언과 동시에 초기화해야 원하는 값으로 사용 가능하다.
    -   식별자 네이밍 규칙은 어떤 것들이 있나요? 👀📚
        -   카멜케이스, 파스칼 케이스, 스네이크케이스, 헝가리안 케이스
    -   네이밍 컨벤션은 어떤 것들이 있나요? 👀📚
        -   위와 동일
    -   리터럴이 뭔가요? 👀📚
        -   프로그래밍에서 자료를 표기하는 방식이다.
        -   변수를 선언하면서 값을 지정하는 방식을 리터럴이라 한다.

```js
let value1 = 123; // 리터럴
```

-   [데이터 타입 🔥](#데이터-타입)

    -   데이터 타입의 종류는 어떤 것들이 있나요? 🔥
        -   원시/참조 타입이 있다.
        -   메모리 영역에 저장되는 방식에 따라 다르다.
        -   원시 타입은 스택에, 참조타입은 힙영역에 존재한다.
    -   심벌 타입은 뭐죠? 👀📚
        -   객체 프로퍼티에 대한 식별자로 사용되며 모든 심볼값은 고유하다.

    ```js
    const symbol1 = Symbol("newKey");
    const symbol2 = Symbol("newKey");

    console.log(symbol1 === sylbol2); // false;

    console.log(symbol1.desctiption); // newKey
    ```

        - 이처럼 Symbol의 인자에 문자열을 추가할 수 있지만 심볼의 설명에 해당하는 값을 설정할 뿐 심볼 자체를 해당 문자열로 생성하는게 아니다. 따라서 두 심볼에 인자가 같다고 해서 같은 심볼을 가지는 것은 아니다.

    ```js
    // 고유키 생성
    const obj = {};
    const sym = Symbol("moon");

    obj[sym] = "moon";

    console.log(obj); // { [Symbol(moon)]: "moon"}
    console.log(obj[sym]); // "moon"
    ```

    ```js
    const obj = {};
    const sym = Symbol("moon");

    obj[sym] = "moon";
    obj["str"] = "string";
    obj.hello = "hello";

    for (let i in obj) {
        console.log(i); // "str" "hello"
    }

    console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(moon)]
    ```

    -   이처럼 심볼로 만든 객체 키값은 감춰진다.
    -   getOwnPropertySymbols 메소드로 접근가능하다.

    -   데이터 타입은 왜 필요할까요? 🔥 👀📚
        -   데이터의 자료형마다 필요한 메모리 공간이 다르기 때문
    -   정적 타이핑이 뭔가요?
        -   변수가 선언될때 자료형이 정해지는것
        -   c 에서 int 형 변수에 문자열을 할당할 수 없다.
    -   동적 타이핑이 뭔가요?
        -   변수선언 이후에도 다른 자료형으로 변경 가능한것
        -   자바스크립트에서 let/var 로 선언한 변수는 문자열, 정수형, 함수, 배열등 모든것이 가능하다.

-   [타입변환과 단축 평가 🔥](#타입변환과-단축-평가)

    -   명시적 타입 변환이 뭔가요? 👀📚
        -   의도적으로 타입을 변경하는것
        -   타입 캐스팅이라 한다.
    -   명시적 타입 변환 함수를 예를 들어볼 수 있나요?
        -   String(), toString() etc...

```js
let a = 1234;
console.log(typeof String(a)); // string
```

    -   암묵적 타입 변환이 뭔가요?
        -   표현식에 의해 타입이 변경되는것

```js
let a = 1234;
console.log(typeof (a + "")); // string
```

    -   truthy / falsy 한 값이 뭔가요?
        -   truthy: 참으로 평가되는 값
        -   숫자 1, 길이가1 이상인 문자열, 배열, 객체 등
        -   falsy: 거짓으로 평가되는 값
        -   숫자 0, 길이가 0인 문자열, null, undefined, NaN 등

-   [배열 🔥](#배열)

    -   자바스크립트의 배열은 자료구조의 배열과 같나요?
        -   다르다. 일반적인 배열은 동일한 크기를 가진 메모리를 연속적으로 가진것(밀집배열)이지만 자바스크립트는 연속적이지 않고 배열의 크기도 일정하지 않다.
        -   배열을 흉내낸 객체에 해당한다. (희소배열)
    -   배열의 메서드는 어떤 종류가 있나요?
        -   push, pop, splice, shift : 원본 수정 O
        -   map, slice, forEach, some, filter : 원본 수정 X
    -   고차 함수에 대해서 아나요? 👀📚
        -   함수를 인수로 전달받거나 함수를 반환하는 함수
        -   ex) map, forEach 등은 함수를 인자로 받는다.
    -   forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
        -   forEach는 각 요소를 순회하기만다.
        -   map은 각 요소를 순회하고 새로운 값으로 리턴한다.

```js
const origin = [1, 2, 3];

const forEachResult = origin.forEach((item) => item + 1); // undefined

const mapResult = origin.map((item) => item + 1); // [2,3,4]
```

-   [객체 리터럴 🔥](#객체-리터럴)

    -   자바스크립트에서 객체란 뭘까요? 👀📚
        -   키와 값으로 구성된 프로퍼티의 집합
    -   함수와 메서드의 차이점에 대해 알고 계신가요? 👀📚
        -   객체의 프로퍼티로 함수도 저장할 수 있다. 이 함수를 메소드라 불린다.
    -   자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?
        -   객체 리터럴, 생성자 함수 사용

```js
const object1 = {}; // 리터럴

const object2 = new Object(); // 생성자 함수
```

-   [원시 값과 객체 비교 🔥](#원시-값과-객체-비교)

    -   동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요? 🔥
        -   데이터가 저장되는 방식이 다르고 이에따라 참조하는 방식이 다르기 때문
    -   값에 의한 전달이 뭔가요? 🔥
        -   값을 새로 복사하는것

```js
let value = 123;

const myFunc = (input) => {
    input += 100;
};

myFunc(value);

// value를 함수로 전달하고 값을 변경하지만 원래 값은 변경되지 않는다.
// input이라는 인자로 복사 되었다.
console.log(value); // 123
```

    -   참조에 의한 전달이 뭔가요? 🔥
        -   값을 새로 복사한것 처럼 보이지만 같은 값을 참조하는것

```js
let value = [1, 2, 3];

const myFunc = (input) => {
    input.push(100);
};

myFunc(value);

// value를 함수로 전달하고 값을 변경하면 원래 배열이 변경된다.
// value와 input은 같은 참조를 가진다.
console.log(value); // [1,2,3,4]
```

-   [함수 🔥](#함수)

    -   자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?
        -   함수 선언문과 함수 표현식이 있다.

```js

const function1 () { ... } // 함수 선언문

const function2 = () => { ... } // 함수 표현식

```

    -   함수 선언문과 함수 표현식은 어떤 차이가 있나요?
        -   함수 선언문은 호이스팅이 발생한다. 선언보다 먼저 접근해도 실행이 가능하다.
        -   함수 표현식도 호이스팅이 발생한다. 단, var,let,const의 호이스팅과 동일하게 발생한다.
    -   즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요 👀📚
        -   정의와 즉시 실행되는 함수
        -   반드시 소괄호로 묶어야 한다.

```js
// 이 익명 함수는 선언과 동시에 실행된다.
  (function () {
      ...
  })();

  // 이 함수도 선언과 동시에 실행된다.
  // 함수의 이름이 있지만 다시 호출할 수 없다.
  (function foo() {
      ...
  })();

  foo(); //ReferenceError: foo is not defined
```

-   [스코프 🔥](#스코프)

    -   스코프가 뭔가요? 🔥🔥
        -   변수가 유효한 범위를 말한다.
    -   스코프에는 어떤 종류가 있죠? 🔥
        -   정적 스코프: 함수가 선언되는 시점에 스코프가 결정
        -   동적 스코프: 함수가 호출되는 시점에 스코프가 결정
        -   전역/지역 스코프도 있음
    -   렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요? 🔥
        -   함수가 선언되는 시점에 스코프가 결정되는것이다.
        -   자바스크립트가 렉시컬 스코프를 따른다.
    -   전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?👀📚
    -   전역 변수를 사용하면 의도하지 않은 문제점이 발생할 가능성이 큰 문제점이 있습니다.
        왜냐하면 전역 변수는 코드 어디서든 참조할 수 있고 할당할 수 있는 유효범위가 넓습니다. (암묵적 결합)
        그리고 전역 변수는 생명 주기도 길기 때문에 오랫동안 변경될 수 있습니다.
        또한 전역 변수를 참조하기 위해서는 스코프체인의 끝에 있기 때문에 검색 속도가 약간 느릴 수 있습니다.
        마지막으로 자바스크립트는 하나의 전역 스코프를 공유하기 때문에 다른 파일에서 동일한 이름의 전역 변수를 사용한다면 예상하지 못한 결과를 얻을 수도 있습니다.
        -   전역객체
        -   브라우저: window
        -   Node.js: global

-   [생성자 함수에 의한 객체 생성 🔥](#생성자-함수에-의한-객체-생성)

    -   생성자 함수가 뭔가요? 👀📚
        -   new 키워드와 함께 호출해서 객체를 생성하는 함수
        -   생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.

```js
const obj = new Func1(); // '생성자 함수'에 의해 '인스턴스'가 생성되었다.
```

        -   String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공
        -

    -   객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요? 👀📚
        -   객체 리터럴은 단 하나의 객체만 생성하기 때문에 같은 프로퍼티를 갖는 객체를 여러개 생성할때 비효율적이다. 생성자 함수를 이용하면 구조가 동일한 객체를 간편하게 생성할 수 있다.

```js
const obj11 = {name: 'Kim', age: ''}; // 리터럴: 매번 동일한 객체 구조를 작성해야 한다
const obj12 = {name: 'Lee', age: ''};
const obj13 = {name: 'Park', age: ''};

function Human (name) {
    this.name = name;
    this.age = 0;
}

const obj 21 = new Human('Kim'); // 생성자 함수: 미리 템플릿을 만들어 놓고 더 간편하게 작성한다.
const obj 22 = new Human('Lee');
const obj 23 = new Human('Park');

```

    -   생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요? 👀📚

```js
// 1. 생성자 함수 선언
function Circle(radius) {
    // 3. 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    };
    // 4. 인스턴스 생성시에 생성자 함수를 호출할 때 넣은 인수를 this 바인딩을 통해 프로퍼티에 할당한 뒤, 인스턴스를 반환한다
}
// 2. 인스턴스 생성
const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
```

-   [함수와 일급 객체 🔥](#함수와-일급-객체)

    -   일급 객체가 뭔가요? 👀📚

        -   "일급"이 최상이 계층 뭐 이런뜻이 아니라 다른 요소들과 아무런 차별이 없다는 뜻.(일반 변수처럼 연산, 저장, 함수 전달 인자, 함수 리턴 모두 가능하다는 뜻)
        -   무명의 리터럴로 생성할 수 있다.
        -   변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
        -   함수의 매개변수에 전달할 수 있다.
        -   함수의 반환값으로 사용할 수 있다.

    -   자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요? 👀📚
        -   아래와 같은게 가능하다.

```js
// 일급객체

// 1. 무명함수를 변수처럼 변수에 할당할 수 있다.
const func1 = () => { ... }

// 2. 함수를 변수처럼 전달인자로 사용이 가능하다 (콜백)
const func2 = (callback) => {
    callback();
}

func2(func1)

// 3. 함수를 변수처럼 리턴값으로 사용이 가능한다.
const func3 = (num) => {
    const func31 = () => {
        return num += 1;
    }

    return func31
}


```

    -   꼬리 질문) 함수형 프로그래밍이 뭔가요? 🔥 👀📚
    -   꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠? 🔥
        - 함수의 결과값이 외부 상태에 의존하지 않고, 부수효과를 발생하지 않는것.

```js
const array = [1, 2, 3];
// 함수가 실행되어도 기존 외부 변수에 영향을 주지 않는다.
const pureFunc = (input) => {
    return input.concat(4);
};

// 함수가 실행되어도 기존 외부 변수가 변경된다.
const normalFunc = (input) => {
    input.push(4);
    return input;
};
```

-   [프로토타입 🔥](#프로토타입)

    -   객체지향 프로그래밍은 무엇을 의미하나요? 🔥 👀📚
        -   프로그램에서 필요한 데이터를 추상화 시켜서 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
        -   명령어나 함수로 이루어진 절차 지향적 관점에서 벗어나 독립적인 단위, 객체의 집합으로 프로그램을 표현하려는것
    -   객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요? 🔥 👀📚
        -   1. 추상화: 객체간 공통적인 특징/기능 추출
        -   2. 상속: 기존 객체의 기능을 다른객체에서 사용할 수 있도록 넘겨주는것
        -   3. 다형성: 부모로부터 받은 메소드를 자식 클래스에서 오버라이딩 되어 사용하는것.
        -   4. 캡슐화: 변수화 함수를 목적에 따라 하나로 묶는 것. 또한 데이터를 함수를 통해서만 접근하도록 하는것
    -   자바스크립트는 객체지향 프로그래밍 언어인가요? 👀📚
        -   자바스크립트는 클래스기반이 아닌 프로토타입기반의 객체지향 프로그래밍
    -   프로토타입이 뭔가요? 👀📚
        -   상속을 구현하기 위해 사용된다.
        -   객체의 원형이라는 의미로 상위객체의 속성을 하위객체에서 접근해서 사용할 수있다.
        -   객체가 만들어지기 위해서 자신을 만드는데 사용한 원형인 프로토타입 객체를 이용해서 생성된다. (자바스크립트는 원시타입을 제외하고 모두 객체)
        -   객체에서 어떤 속성이나 메소드에 접근할때 현재 객체에 없으면 해당객체의 상위 프로토타입에서 접근해서 찾는다. 이를 프로토타입 체인이라고 한다.(스코프 체인과 비슷한듯)

-   [strict mode 🔥](#strict-mode)

    -   strict mode가 뭔가요?
        -   자바스크립트 문법 실수 방지 모드
        -   “use strict” 키워드로 적용 가능
    -   strict mode를 통해 무엇을 예방할 수 있죠?

```js

// 1. 암묵적 전역 방지 window.x 로 등록됨.
x = 20;

// 2. 중복 매개변수 방지
const func1 = (param1, param1) => { ... }

// 3. delete 방지
let a = 1;
delete a;

// 그외 다수

```

-   [빌트인 객체 🔥](#빌트인-객체) 👀📚

    -   빌트인 객체가 뭔가요? 👀📚
        -   자바스크립트에서 기본적으로 제공하는 객체
    -   빌트인 객체의 종류는 어떤게 있죠? 👀📚
        -   Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여개
    -   래퍼 객체에 대해서 알고 있나요? 👀📚
        -   원시 타입을 객체 타입처럼 사용하는 과정 속에서 생기는 임시 객체. 원시 타입인 String, Number, Boolean 으로 특정된다.
        -   원시 값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시 값으로 되돌린다.

```js
let str = "hello"; // str은 원시 타입이다.

console.log(str.length); // 원시 타입에 객체 접근법을 사용하고있다.
// str은 원시타입이지만 객체의 프로퍼티 접근처럼 사용해서 내부 메소드를 사용할 수 있다.
//이때 연관된 String 객체를 생성하고 메소드를 수행한 뒤 다시 원시값으로 되돌린다.
```

-   [this 🔥](#this) 👀📚

    -   this가 뭔가요? 🔥
        -   자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
        -   this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.
    -   this 바인딩이란? 🔥
        -   식별자(변수)와 값을 연결하는 과정
        -   변수 선언은 변수이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는것
        -   this바인딩은 this와 this가 가리킬 객체를 바인딩하는것
    -   this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

| 함수 호출 방식                                             | this 바인딩                                                            |
| :--------------------------------------------------------- | :--------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체(window/ global)                                              |
| 콜백 함수 호출                                             | 전역 객체(window/ global)                                              |
| 내부 함수 호출                                             | 전역 객체(window/ global)                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                                 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

-   [실행 컨텍스트 🔥](#실행-컨텍스트)

    -   실행 컨텍스트에 대해 말해보세요 🔥🔥
        -   코드가 평가되고 실행되는 환경
        -   자바스크립트는 실행할 코드를 실행 컨텍스트 단위로 메모리 스택에 순서대로 push하고, pop하면서 실행한다.

-   [클로저 🔥](#클로저)

    -   클로저에 대해서 아나요? 🔥🔥
        -   자신이 선언될 당시의 환경을 기억하는 함수
    -   클로저를 사용하면 뭐가 좋죠? 🔥
        -   특정 함수의 지역변수를 외부에서 사용할 수 있다.
        -   private변수처럼 사용할 수 있다.
    -   클로저를 어떻게 생성하나요? 🔥
        -   다음 예시로 설명

```js
const outer = () => {
    let value = 0;
    const inner = () => {
        return (value += 1);
    };
    return inner;
};

const a = outer();

a(); // 1
a(); // 2
a(); // 3
```

-   [클래스 🔥](#클래스) 👀📚

    -   자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?
        -   생성자 함수와 프로토타입을 이용한다.

```js
// ES5 생성자 함수
function Person(name) {
    this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
    console.log("Hi! My name is " + this.name);
};

// 인스턴스 생성
var me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

    -   그럼 생성자 함수와 클래스는 어떤 차이가 있나요?
        -   클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만, 생성자 함수는 일반 함수로 호출된다.
        -   클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 생성자 함수는 해당 키워드를 제공하지 않는다.
        -   클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 작성된 클래스는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
        -   클래스 내의 모든 코드에는 암묵적으로 strict mode가 저장되어 실행되며 strict mode를 해제할 수 없다. <-> 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
    -   클래스 정의
    -   클래스의 상속

```js
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

-   [스프레드 문법 🔥](#스프레드-문법)

    -   spread 문법이 뭔가요?
        -   값을 전개 하는 문법

```js
const a = [1, 2, 3];
console.log(...a); // 1 2 3
```

    -   어떤 상황에서 사용할 수 있죠?
        -   기존 값을 나열해서 리턴할 때 새로운 값을 리턴하기 때문에 배열이나 객체의 깊은 복사에 사용할 수 있다.
        -   혹은 기존 배열/객체 값의 수정, 추가에도 사용 가능하다.

-   [구조 분해 할당 🔥](#구조-분해-할당)

    -   구조 분해 할당이 뭔가요?
        -   값을 해체해서 개별 변수에 담는 것.
    -   구조 분해 할당은 크게 어떤 종류가 있나요?
        -   배열 구조분해할당
        -   객체 구조분해할당

```js
// 배열
const arr = [1, 2, 3];
const [one, two, three] = arr; // one: 1, two: 2, three: 3 이 담긴다.

// 객체
const obj = { name: "Kim", age: 90 };
const { name, age } = obj; // name: name: 'Kim', age: 90 이 담긴다. 단, 변수와 키 값이 동일해야한다.
```

\*uri 와 url 차이, dns 란 무엇인가

-   [브라우저 렌더링 과정 🔥](#브라우저-렌더링-과정) 👀📚
-   참고: https://mystudy.tistory.com/21

        -   브라우저의 렌더링 과정에 대해 설명해보세요 🔥
            -   1. 클라이언트에서 요청한 URI를 DNS를 통해 IP주소로 변환하고, 해당 IP를 가진 서버에 GET요청을 보낸다.
            -   2. 서버에서 응답으로 받은 HTML 데이터를 파싱하고 DOM 트리 생성을 시작한다.
                -   1 브라우저는 서버 응답으로 받은 HTML문서를 2진수 형태로 응답 받는다.
                -   2 이를 HTML마크업 문자열로 변경
                -   3 문자열을 의미를 가진 토큰으로 변환

![토큰화](./HTML%ED%86%A0%ED%81%B0%ED%99%94.png)

            -   4.의미를 가진 토큰을 관계성을 가진 노드로 변환

![토큰화](./HTML%EB%85%B8%EB%93%9C%ED%99%94.png)

            -   노드란 DOM Tree를 구성할수 있는 단위이다.
            -   HTML요소의 집합으로 이루어진 HTML 문서는 부모/자식 관계가 존재하는데 이를 반영해서 트리 자료구조로 구성한다.
            -   이러한 트리 자료구조를 DOM 이라 한다.

![브라우저 렌더링](./%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%ED%8C%8C%EC%8B%B1.png)

        -   3. css마크업을 바탕으로 CSSOM  트리를 생성한다 (바이트 > 문자 > 토큰 > 노드 > CSSOM
        -   4. DOM트리와 CSSOM트리를 결합하여 렌더 트리를 형성한다.
            -   렌더 트리란 DOM과 CSSOM을 합한 후 최종적으로 브라우저에 표기될 것들만 선별되어 생성된다.
            -   이때 display:none 과같이 화면에 나타나지 않을 속성들은 렌더 트리에서 누락된다.
        -   5. 렌더 트리에서 레이아웃을 실행한다. (레이아웃 과정)
            -   렌더 트리를 기반으로 HTML요소의 위치와 크기를 계산한다. %, vh 등은 픽셀로 계산된다.
        -   6. 레이아웃을 통해 얻은 위치에 실제 요소를 그린다.(페인트 과정)
            -
    -   브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
        -   HTML파일 파싱 과정에서 script 태그를 만나면 (별도의 옵션이 없는 한) 파싱을 멈추고 자바스크립트 파일을 해석하고 실행한다.
            -   옵션1. script 태그에 async 속성이 있으면 파싱과 동시에 자바스크립트를 다운로드 하고, 다운로드가 종료되는 즉시 파싱을 멈추고 스크립트를 실행한다.
            -   옵션2. script 태그에 defer 속성이 있으면 async와 동일하게 파싱과 동시에 자바스크립트를 다운로드하지만, HTML 파싱이 종료되고 나서 스크립트를 실행한다.
    -   `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까요?
        - HTML 이 다 구성되지 않은 상태에서 스크립트를 실행하면 존재하지 않는 DOM에 접근하게되어 오류를 발생시킬 수 있기 때문

-   [DOM 🔥](#DOM) 👀📚

    -   DOM이 뭔가요?
        -   HTML문서를 객체화 한 것 위에서 본 그림중에서 바이트 형태의 응답을 최종적으로 트리 형태로 구현한 것을 확인할 수 있다. 이 최종 트리 형태를 DOM 이라고 한다.
    -   DOM을 구성하는 건 뭐가 있나요?
        -   1. 문서노드
            -   트리 최상위에 존재하는 루트 노드로서 document객체를 가리킨다.

```js
<!DOCTYPE>
```

        -   2. 요소 노드
            -   HTML 요소를 가리킨다. 문서의 구조를 표현한다.

```js
<html> <head> <meta> <link> <body> <ul> <li> <script> // 등등
```

        -   어트리뷰트 노드
            -   HTML요소의 어트리뷰트를 가리킨다. 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어있다.

```js
charset="UTF"

rel="stylesheet"
...

id="apple"
```

        - 텍스트 노드
          - HTML요소와 텍스트를 가리키는 객체다. 요소노드가 문서의 구조를 표현한다면 텍스트 노드는 문서의 정보를 표현한다.

-   [이벤트 🔥](#이벤트)

        -   마우스 이벤트 타입에는 뭐가 있나요? click 말고 클릭을 대체할 수 있는 이벤트가 있나요?
            -   mouseup 이벤트 (누른걸 뗄 때 발생)

    | 이벤트 타입 | 이벤트 발생 시점                                      |
    | :---------- | :---------------------------------------------------- |
    | click       | 마우스 버튼을 클릭했을 때                             |
    | dbclick     | 마우스 버튼을 더블 클릭했을 때                        |
    | mousedown   | 마우스 버튼을 누르고 있을 때                          |
    | mouseup     | 누르고 있던 마우스 버튼을 뗄 때                       |
    | mousemove   | 마우스 커서를 움직일 때                               |
    | mouseenter  | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 x) |
    | mouseover   | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 o) |
    | mouseleave  | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링x)   |
    | mouseout    | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링o)   |

        -   그 외에 알고 있는 대표적인 이벤트가 있나요?

### 키보드 이벤트

| 이벤트 타입 | 이벤트 발생 시점                            |
| :---------- | :------------------------------------------ |
| keydown     | 키를 누르고 있을 때                         |
| keypress    | 키를 누르고 뗏을 때 (폐지되었으므로 사용 x) |
| keyup       | 누르고 있던 키를 뗄 때                      |

### 포커스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                     |
| :---------- | :----------------------------------- |
| focus       | 요소가 포커스를 얻었을 때 (버블링 x) |
| blur        | 요소가 포커스를 잃었을 때 (버블링 x) |
| focusin     | 요소가 포커스를 얻었을 때 (버블링 o) |
| foucusout   | 요소가 포커스를 잃었을 때 (버블링 o) |

### 폼 이벤트

| 이벤트 타입 | 이벤트 발생 시점                            |
| :---------- | :------------------------------------------ |
| submit      | form을 submit할 때 (버튼 또는 키)           |
| reset       | reset 버튼을 클릭할 때 (최근에는 사용 안함) |

### 값 변경 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                          |
| :---------- | :-------------------------------------------------------- |
| input       | input 또는 textarea 요소의 값이 변경되었을 때             |
| change      | select box, checkbox, radio button의 상태가 변경되었을 때 |

### DOM 뮤테이션 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                            |
| :--------------- | :---------------------------------------------------------- |
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때 |

### 뷰 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                |
| :---------- | :-------------------------------------------------------------- |
| resize      | 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생          |
| scroll      | 웹피이지(document) 또는 HTML 요소를 스코롤할 때 연속적으로 발생 |

### 리소스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                           |
| :---------- | :--------------------------------------------------------- |
| load        | DOMContentLoaded 이후, 모든 리소스의 로딩이 완료되었을 때  |
| unload      | 리소스가 언로드 될 때 (주로 새로운 웹페이지를 요청한 경우) |
| abort       | 리소스 로딩이 중단되었을 때                                |
| error       | 리소스 로딩이 실패했을 때                                  |

    -   이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?

1. 이벤트 핸들러 어트리뷰트 방식

```html
<!DOCTYPE html>
<html>
    <body>
        <button onclick="sayHi('Lee')">Click me!</button>
        <script>
            function sayHi(name) {
                console.log(`Hi! ${name}.`);
            }
        </script>
    </body>
</html>
```

2. 이벤트 핸들러 프로퍼티 방식

```html
<!DOCTYPE html>
<html>
    <body>
        <button>Click me!</button>
        <script>
            const $button = document.querySelector("button");
            // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩 (익명 함수로 가능)
            $button.onclick = function () {
                console.log("button click");
            };
        </script>
    </body>
</html>
```

3. addEventListener 메서드 방식

```html
<html>
    <body>
        <button>Click me!</button>
        <em></em>

        <script>
            const $button = document.querySelector("button");
            const $em = document.querySelector("em");
            $button.addEventListener("click", function () {
                $em.innerHTML = "Button Cliked 1";
            });
        </script>
    </body>
</html>
```

    -   이벤트 전파(propagation)에 대해서 알고 있나요?
        -   DOM 트리상에 존재하는 DOM 노드에서 발생한 이벤트 는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.
    -   이벤트 위임(delegation)에 대해서 알고있나요? 🔥
        -   요소마다 이벤트 핸들러를 할당하지 않고, 공통 조상에 이벤트 핸들러를 할당해서 하위 자식 요소의 이벤트를 다루는것
    -   e.preventDefault 에 대해 알고 있나요?
        -   요소의 기본 동작 중단
    -   e.stopPropagation
        -   이벤트 전파 중단

-   [타이머 🔥](#타이머) 👀📚

    -   호출 스케쥴링이 무엇인가요?
        -   자바스크립트의 함수는 기본적으로 즉시 호출되지만 타이머 함수를 이용해서 함수 호출을 예약하는것
    -   타이머 함수에는 어떤 것들이 있나요?
        -   setTimeout, setInterval
    -   이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?
        -   디바운스와 쓰로틀을 사용한다? (프로그래밍 기법이라고 한다)
    -   디바운스에 대해서 알고 있나요?
        -   짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정시간이 경과된 이후에 이벤트 핸들러가 한번만 호출되도록 한다.
        -   짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한번만 호출되도록 한다.
        -   마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출 되지 않도록 하는 것.
    -   쓰로틀에 대해서 알고 있나요?
        -   연이어 호출되는 함수들 중 마지막(혹은 처음)만 호출 하도록 하는것

ex) 검색 api를 호출한다고 가정한다.

만약 모든 입력마다 api를 호출하면
검색어: 프론트엔드 일때
ㅍ -> 프 -> 플 -> 프로 .. -> 프론트엔드
모든 경우에 대해 api를 호출하게 된다.

이때 디바운스 기법을 적용한다면
입력 이후 200ms 동안 입력이 없으면 api를 호출한다.
즉, 엄청나게 긴 문자열을 입력하다가 200ms간 입력이 없으면 현재까지 입력한 문자열로 api를 요청한다.

쓰로틀 기법을 이용한다면
동일하게 200ms를 기준으로 했을때 200ms 마다 한번씩 api를 호출하게 된다.

-   [비동기 프로그래밍 🔥](#비동기-프로그래밍)

    -   동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥

        -   동기: 한번에 하나씩 처리
        -   비동기: 한번에 여러개를 시작

    -   이벤트 루프와 태스크 큐에 대해서 알고 있나요? 🔥🔥
        -   자바스크립트 코드에서 비동기 작업 setTimeout, setInterval 은 비동기 작업이기 때문에 스택에서 pop 되고 태스크 큐로 들어간다.
        -   이후 이벤트 루프에 의해 현재 큐에서 끝난 작업이 있는지, 스택이 비어있는지 체크해서 태스크 큐에서 작업이 완료된 것을 스택으로 push 한다.
    -   마이크로태스크 큐에 대해서 알고 있나요? 🔥
        -   promise에 의해 발생하는 비동기 작업이 들어온다.
        -   일반 태스크 큐 보다 우선순위가 높다.
    -   태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥
        -   일반 태스크 큐 보다 마이크로태스크 큐의 우선순위가 높다.

-   [Ajax 🔥](#Ajax) 👀📚

    -   Ajax가 뭔가요 어떤 것을 담당하고 있죠?

        -   Asynchronous JavaScript and XML. 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식이다.
        -   Ajax 는 XMLHttpRequest 객체를 기반으로 동작한다.

    -   Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?
        -   기존 웹은 html태그로 시작해서 끝나는 완전한 html만 주고받을 수 있었다면, ajax에 의해 필요한 데이터만 받아서 필요한 부분만 렌더링 하는 방식을 가능하게 한다.
    -   JSON 이 뭔가요?
        -   JavaScript Object Notation
        -   클라이언트와 서버 간의 http통신을 위한 텍스트 데이터 포맷
    -   JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?
        -   1. JSON.stringfy()
            -   객체를 문자열로 변경한다. (함수, 배열, 객체 다 문자열로 변경)
        -   2. JSON.parse()
            -   문자열을 객체로 변경한다.
    -   Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?
        -   XMLHttpRequest, fetch
    -   XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요? 🔥
        -   fetch는 프로미스를 지원하기 때문에 비동기 처리가 더 수월함

-   [REST API 🔥](#REST-API) 👀📚

    -   REST API가 뭔가요?
        -   REST는 어떤 리소스를 이름으로 구분해서 자원의 상태를 주고받는 방식을 의미함
        -   REST API는 REST를 기반으로 작성된 API서비스를 의미함
        -   API란 응용프로그램에서 데이터를 주고받기 위한 방법을 의미함
    -   REST API의 구성은 어떤 것이 있나요?
        -   REST API는 **① 자원(resource), ② 행위 (verb), ③ 표현 (representations)** 의 3가지 요소로 구성된다.

| 구성 요소             | 내용                           | 표현 방법        |
| :-------------------- | :----------------------------- | :--------------- |
| 자원(resource)        | 자원                           | URI(엔드 포인트) |
| 행위(verb)            | 자원에 대한 행위               | HTTP 요청 메서드 |
| 표현(representations) | 자원에 대한 행위의 구체적 내용 | 페이로드         |

    -   REST API를 설계하는데 중요한 것이 있을까요?
        -   1. uri는 리소스 표현하는데 집중한다.
        -   2. 행위에 대한 정의는 http요청 매서드를 이용한다.

```js
# bad
GET /getTodos/1
GET /todos/show/1

// get, show 와 같은 표현은 http요청 메서드 GET으로 대신한다.

# good
GET /todos/1
```

-   참고

# 리소스

-   웹 브라우저 파일 및 그 이외의 자원들

# URI 와 URL

-   URI: 인터넷상의 리소스를 식별하는 문자열
-   URL: 리소스의 위치를 나타내기 위한 규약 (리소스가 무엇인지 + 위치가 어디인지)

![URI/URL](./URI%20URL%20URN.png)

-   Scheme: 리소스에 접근하는 데 사용할 프로토콜. 웹에서는 http 또는 https를 사용
-   Host: 접근할 대상(서버)의 호스트 명
-   Path: 접근할 대상(서버)의 경로에 대한 상세 정보

    -   HTTP 요청 메서드에 대해서 아는대로 얘기해보세요

| HTTP 요청 메서드 | 종류           | 목적                  | 페이로드 |
| :--------------- | :------------- | :-------------------- | :------- |
| GET              | index/retrieve | 모든/특정 리소스 취득 | x        |
| POST             | create         | 리소스 생성           | o        |
| PUT              | replace        | 리소스의 전체 교체    | o        |
| PATCH            | modify         | 리소스 일부 수정      | o        |
| DELETE           | delete         | 모든/특정 리소스 삭제 | x        |

    -   HTTP 상태 코드를 아는대로 말해주세요 🔥
        -   200 성공, 201 성공+리소스 생성, 400 실패 등등..

`2XX`

| 상태 코드 | 코드 명 | 의미                                                    |
| :-------: | :-----: | :------------------------------------------------------ |
|    200    |   OK    | 요청이 성공적으로 보내졌음을 의미                       |
|    201    | Created | 요청이 성공적이였으며 새로운 리소스가 생성되었음을 의미 |

`4XX`

| 상태 코드 |   코드 명   | 의미                                                       |
| :-------: | :---------: | :--------------------------------------------------------- |
|    400    | Bad Request | 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미 |
|    401    | Unathorized | 비인증(Unathorize)된 요청임을 의미                         |
|    403    |  Forbidden  | 콘텐츠에 접근할 권리를 가지고 있지 않음을 의미             |
|    404    |  Not Found  | 요청받은 리소스를 찾을 수 없음을 의미                      |

`5XX`

| 상태 코드 |        코드 명        | 의미                                  |
| :-------: | :-------------------: | :------------------------------------ |
|    500    | Internal Server Error | 서버가 처리 방법을 모르는 상황을 의미 |

-   [Promise 🔥](#Promise)

    -   콜백이란 뭐라고 생각하나요? 🔥
        -   함수를 다른 함수의 인자로 전달해서 해당 이벤트 내에서 함수를 실행하는것
        -   비동기 통신의 결과에 대해 작업을 수행할 때 작업종료 시점을 알 수 없기 때문에 비동기 통신에 실행할 함수를 콜백으로 전달해서 실행 순서을 보장받을 수 있다.
    -   프로미스가 뭔가요? 🔥
        -   ES6에서 추가된 비동기 처리 패턴.
        -   콜백을 이용한 비동기 처리는 들여쓰기 때문에 가독성이 저하되는 경우가 있다.
        -   프로미스는 이런 부분을 해결해준다.
        -   프로미스는 비동기를 처리할 콜백함수를 전달받는다. 성공의 경우 resolve, 실패의 경우 reject 함수를 실행한다.

```js
// case 1 : 콜백 HELL 🔥

get("/step1", (a) => {
    get(`/step2/${a}`, (b) => {
        get(`/step3/${b}`, (c) => {
            get(`/step4/${c}`, (d) => {
                console.log(d);
            });
        });
    });
});

// case 2 : 프로미스

promise1.then((res) => {
    promise2.then((res) => {
        promise3.then((res) => {
            promise4.then((res) => {});
        });
    });
});

// 비슷함.
```

    -   프로미스 생성 방법

```js
// Promise
const myPromise = new Promise((resolve, reject) => {
    if(/*비동기 작업 성공*/) {
        resolve('success')
    }
    else {
        reject('fail')
    }
})
```

    -   프로미스의 상태를 나타내는 것은 어떤 것들이 있나요? 🔥 👀📚

| 프로미스의 상태 정보 | 의미                                  | 상태 변경 조건                   |
| :------------------- | :------------------------------------ | :------------------------------- |
| pending              | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled            | 비동기 처리가 수행된 상태(성공)       | resolve 함수 호출                |
| reject               | 비동기 처리가 수행된 상태(실패)       | reject 함수 호출                 |

    -   프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요? 🔥 👀📚

-   Promise.resolve/ Promise.reject
-   Promise.all : 여러개의 비동기 처리를 병렬적으로 처리. 모든 프로미스가 종료되면 종료한다. 처리 결과를 첫번째 프로미스 부터 배열에 저장해서 새로운 프로미스를 반환한다.
-   Promise.race : 여러개의 비동기 처리중 가장먼저 fulfilled된 프로미스의 처리결과만 받음
-   Promise.allSettled : 여러개의 비동기 처리가 모두 fulfilled/reject가 되면 결과를 배열로 반환한다.

-   Promise.all 과 Promise.allSettled 의 차이
    -   .all 은 프로미스 처리중 하나라도 reject 되는 즉시 에러가 발생한다.
    -   .allSettled는 성공이든 실패든 모든 결과를 담아서 리턴한다.
-   [제너레이터와 async await 🔥](#제너레이터와-async-await) 👀📚

    -   제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?
        -   일반함수는 호출되면 그 실행 순서를 조작할 수 없지만 제너레이터는 yeild키워드와 next 메서드를 통해 실행을 중지하고 다시 시작 할 수 있다.
        -
    -   제너레이터의 구조

        -   제너레이터는 ① yield 키워드와 ② next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.

        -   일반 함수는 호출 이후 제어권을 해당 함수가 독점하지만, 제너레이터는 함수 호출자에게 제어권을 양도(yield)하여 필요한 시점에 함수 실행을 재개할 수 있다.

        -   next 메서드를 통해 제너레이터를 실행할 경우, 코드 블록 내에 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 리절트 객체형식으로 반환한다.

```js
// 제너레이터 함수
function* genFunc() {
    yield 1;
    yield 2;
    yield 3;
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
// 이터러블이면서 동시에 이터레이터인 제너레이터 객체는 next 메서드를 갖는다.
const generator = genFunc();

console.log(generator.next()); // {value: 1, done: false}

console.log(generator.next()); // {value: 2, done: false}

console.log(generator.next()); // {value: 3, done: false}

console.log(generator.next()); // {value: undefined, done: true}
```

    -   async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 🔥
        -   promise로 처리한 비동기 작업은 .then, .catch, .finally등의 메서드에 콜백 함수를 전달하는 방식이지만 async/await는 콜백함수가 필요없다.
        -   동기 처리 처럼 비동기 작업을(프로미스를) 처리할 수 있다.
    -   Promise와 async/await의 차이점 한 줄 요약 🔥
        -   비동기 처리 방식이 다르다.
        -   코드 가독성이 async/await가 우월하다

```js
// case 1 : 콜백 HELL 🔥

get("/step1", (a) => {
    get(`/step2/${a}`, (b) => {
        get(`/step3/${b}`, (c) => {
            get(`/step4/${c}`, (d) => {
                console.log(d);
            });
        });
    });
});

// case 2 : 프로미스

promise1.then((res) => {
    promise2.then((res) => {
        promise3.then((res) => {
            promise4.then((res) => {});
        });
    });
});

// case 3 : 프로미스 + async + await
// 들여쓰기, 콜백함수없이 비동기 처리를 할 수 있다.
const doPromise = async () => {
    const result1 = await promise1();
    const result2 = await promise2();
    const result3 = await promise3();
    const result4 = await promise4();
};
```

async await로 구현할 경우 제너레이터의 성질을 갖기 때문에 항상 프로미스가 settled(이행된) 상태가 될 때까지 대기한다.

따라서 모든 코드에 async await를 남발하는 것은 도움이 되지 않는다

```js
async function foo() {
    const a = await new Promise((resolve) =>
        setTimeout(() => resolve(1), 3000)
    );
    const b = await new Promise((resolve) =>
        setTimeout(() => resolve(2), 2000)
    );
    const c = await new Promise((resolve) =>
        setTimeout(() => resolve(3), 1000)
    );

    console.log([a, b, c]); // [1, 2, 3]
}

foo(); // 약 6초 소요된다.

// -----------------

async function foo() {
    const res = await Promise.all([
        new Promise((resolve) => setTimeout(() => resolve(1), 3000)),
        new Promise((resolve) => setTimeout(() => resolve(2), 2000)),
        new Promise((resolve) => setTimeout(() => resolve(3), 1000)),
    ]);

    console.log(res); // [1, 2, 3]
}

foo(); // 약 3초 소요된다.
```

-   [에러 🔥](#에러) 👀📚

    -   에러처리를 왜 해야 하나요?
        -   에러 처리를 하지 않으면 프로그램은 강제 종료된다.
        -   예상치 못한 프로그램의 강제종료를 방지하기 위해 에러처리는 반드시 필요하다
    -   자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?
        -   try / catch / finally
        -   Error 객체
            -   Error 생성자 함수는 에러 객체를 생성한다.
            -   Error 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.
        -   throw 문
            -   Error 생성자 함수로 에러객체를 생성한다고 해서 에러를 발생시킨건 아니다.
            -   에러를 발생시키려면 try 코드 블럭에서throw문으로 에러를 던져야 한다.

```js
// 에러 객체 생성
const error = new Error("invalid");

// 에러 생성
try {
    // 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.
    new Error("something wrong");
} catch (error) {
    console.log(error);
}

// 에러 발생
try {
    // 에러 객체를 던지면 catch 코드 블록이 실행되기 시작한다.
    throw new Error("something wrong");
} catch (error) {
    console.log(error);
}
```

-   [모듈 🔥](#모듈) 👀📚

    -   모듈이 뭔가요?
        -   애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.
        -   모듈은 파일 단위로 분리되어있으며 자신만의 자산(변수, 함수, 객체)는 기본적으로 비공개 상태다. (애플리케이션과 분리되어 존재한다)
        -   따라서 모듈은 공개가 가능한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 export 라고 한다.
        -   모듈 사용자는 공개한(export)한 자산중 일부를 자신의 스코프 내로 불러들여 재사용 할 수 있다. 이를 import 라 한다.
