## 목차

-   [프로그래밍 🔥](#프로그래밍)

    -   프로그래밍이란 뭐라고 생각하나요?

    -   컴파일러는 뭐고 인터프리터는 뭔가요? 🔥

사람이 작성한 코드를 컴퓨터가 실행할 수 있도록 기계어로 해석해주는것
컴파일러는 전체 코드를 한번에 변경하고 인터프리터는 한줄씩 해석한다.

컴파일러는 전체 코드를 변경하기 때문에 최종 실행되기 전 타입에러등을 검출하지만
인터프리터는 한줄씩 해석/실행 하기 때문에 오류가 발생한 코드에 도달해야 오류가 발생한다.

-   [자바스크립트란 🔥](#자바스크립트란)

    -   자바스크립트의 특징은 뭐가 있나요?

1. 렉시컬 스코프
   자바스크립트는 함수단위로 실행되는데 함수의 유효범의 즉 접근가능한 변수의 범위는 함수의 소출이 아닌 선언시점에 결정된다.
2. 싱글 스레드 기반
   하나의 스택을 가지고 실행맥락 단위로 쌓인 코드가 한번에 하나씩 실행된다. 따라서 한번에 하나의 작업만 가능하지만 자바스크립트 런타임에의해 생성되는 태스크큐, 마이크로큐, 웹 api, 이벤트루프 등에의해 비동기 작업을 수행할 수 있다.
3. 웹프로그래밍을 위해서 제작된 언어. 브라우저 환경에서만 실행될 수 있는 언어지만 Node.js의 등장으로 웹으로부터 독립적인 환경에서 실행 가능하다.

-   [변수 🔥](#변수)

    -   변수란 무엇인가요?
        -   데이터를 담을 공간
    -   식별자란 무엇인가요? 🔥
        -   데이터를 담을 공간을 식별하는 이름
    -   변수를 선언한다는 것은 어떤 것을 의미하나요?
        -   데이터를 저장하기위한 메모리 공간을 확보하는것
    -   var 키워드는 뭔가요?
        -   자바스크립트의 변수 선언 키워드
    -   호이스팅이 뭔가요? 🔥🔥
        -   자바스크립트는 함수단위로 실행된다. 이때 함수를 실행하기 전 함수 내부의 모든 변수 정보를 실행맥락에 등록한다. 이때 변수의 선언과 초기화 단계를 거치게 되는데 실제 코드가 실행되기 전 이미 메모리 공간에 할당되기 때문에 마치 변수의 선언문이 최상단으로 끌어올라간듯한 현상을 말한다.
    -   var 키워드의 문제점은 무엇이 있나요? 🔥
        -   1. 최 상단 범위에서 선언하는 경우 window객체에 변수가 등록된다.
        -   2. 중복 선언이 허용된다.
        -   3. 변수의 유효범위가 함수스코프를 따른다.
    -   let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥
        -   let 키워드는
        -   1. 유효범위가 다르다. 블록 스코프를 따른다.
        -   2. 중복 선언이 불가능하다.
        -   즉, 서로다른 스코프에서 선언된 동일한 이름의 let 변수는 서로 다른 변수다.
    -   TDZ 🔥🔥
        -   호이스팅은 함수가 실행되기전 함수의 실행맥락에 내부의 모든 변수가 선언/초기화 단계를 거치면서 등록되는 것이라 했다. 이때 var 키워드 변수는 선언/초기화 단계를 거치면서 변수가 undefined로 초기화된 메모리를 참초하는 반면, let/const 키워드는 선언 단계만 거치기 때문에 변수를 사용할 준비는 되었으나 어떤 메모리 공간도 참조하지 못한 상태다. 따라서 var 와 다르게 선언 이전에 접근하는 경우 참조에러가 발생한다.
    -   const 키워드는 어떤 특징이 있나요? 🔥
        -   한번 초기화된 변수는 재할당이 불가능하기 때문에 상수처럼 사용가능하다.
        -   따라서선언과 동시에 초기화해야 원하는 값으로 사용 가능하다.
    -   식별자 네이밍 규칙은 어떤 것들이 있나요? 👀📚
        -   카멜케이스, 파스칼 케이스, 스네이크케이스, 헝가리안 케이스
    -   네이밍 컨벤션은 어떤 것들이 있나요? 👀📚
        -   위와 동일
    -   리터럴이 뭔가요? 👀📚
        -   프로그래밍에서 자료를 표기하는 방식이다.
        -   변수를 선언하면서 값을 지정하는 방식을 리터럴이라 한다.

```js
let value1 = 123; // 리터럴
```

-   [데이터 타입 🔥](#데이터-타입)

    -   데이터 타입의 종류는 어떤 것들이 있나요? 🔥
        -   원시/참조 타입이 있다.
        -   메모리 영역에 저장되는 방식에 따라 다르다.
        -   원시 타입은 스택에, 참조타입은 힙영역에 존재한다.
    -   심벌 타입은 뭐죠? 👀📚
        -   객체 프로퍼티에 대한 식별자로 사용되며 모든 심볼값은 고유하다.

    ```js
    const symbol1 = Symbol("newKey");
    const symbol2 = Symbol("newKey");

    console.log(symbol1 === sylbol2); // false;

    console.log(symbol1.desctiption); // newKey
    ```

        - 이처럼 Symbol의 인자에 문자열을 추가할 수 있지만 심볼의 설명에 해당하는 값을 설정할 뿐 심볼 자체를 해당 문자열로 생성하는게 아니다. 따라서 두 심볼에 인자가 같다고 해서 같은 심볼을 가지는 것은 아니다.

    ```js
    // 고유키 생성
    const obj = {};
    const sym = Symbol("moon");

    obj[sym] = "moon";

    console.log(obj); // { [Symbol(moon)]: "moon"}
    console.log(obj[sym]); // "moon"
    ```

    ```js
    const obj = {};
    const sym = Symbol("moon");

    obj[sym] = "moon";
    obj["str"] = "string";
    obj.hello = "hello";

    for (let i in obj) {
        console.log(i); // "str" "hello"
    }

    console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(moon)]
    ```

    -   이처럼 심볼로 만든 객체 키값은 감춰진다.
    -   getOwnPropertySymbols 메소드로 접근가능하다.

    -   데이터 타입은 왜 필요할까요? 🔥 👀📚
        -   데이터의 자료형마다 필요한 메모리 공간이 다르기 때문
    -   정적 타이핑이 뭔가요?
        -   변수가 선언될때 자료형이 정해지는것
        -   c 에서 int 형 변수에 문자열을 할당할 수 없다.
    -   동적 타이핑이 뭔가요?
        -   변수선언 이후에도 다른 자료형으로 변경 가능한것
        -   자바스크립트에서 let/var 로 선언한 변수는 문자열, 정수형, 함수, 배열등 모든것이 가능하다.

-   [타입변환과 단축 평가 🔥](#타입변환과-단축-평가)

    -   명시적 타입 변환이 뭔가요? 👀📚
        -   의도적으로 타입을 변경하는것
        -   타입 캐스팅이라 한다.
    -   명시적 타입 변환 함수를 예를 들어볼 수 있나요?
        -   String(), toString() etc...

```js
let a = 1234;
console.log(typeof String(a)); // string
```

    -   암묵적 타입 변환이 뭔가요?
        -   표현식에 의해 타입이 변경되는것

```js
let a = 1234;
console.log(typeof (a + "")); // string
```

    -   truthy / falsy 한 값이 뭔가요?
        -   truthy: 참으로 평가되는 값
        -   숫자 1, 길이가1 이상인 문자열, 배열, 객체 등
        -   falsy: 거짓으로 평가되는 값
        -   숫자 0, 길이가 0인 문자열, null, undefined, NaN 등

-   [배열 🔥](#배열)

    -   자바스크립트의 배열은 자료구조의 배열과 같나요?
        -   다르다. 일반적인 배열은 동일한 크기를 가진 메모리를 연속적으로 가진것이지만 자바스크립트는 연속적이지 않고 배열의 크기도 일정하지 않다.
        -   배열을 흉내낸 객체에 해당한다.
    -   배열의 메서드는 어떤 종류가 있나요?
        -   push, pop, splice, shift : 원본 수정 O
        -   map, slice, forEach, some, filter : 원본 수정 X
    -   고차 함수에 대해서 아나요? 👀📚
        -   함수를 인수로 전달받거나 함수를 반환하는 함수
        -   ex) map, forEach 등은 함수를 인자로 받는다.
    -   forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
        -   forEach는 각 요소를 순회하기만다.
        -   map은 각 요소를 순회하고 새로운 값으로 리턴한다.

```js
const origin = [1, 2, 3];

const forEachResult = origin.forEach((item) => item + 1); // undefined

const mapResult = origin.map((item) => item + 1); // [2,3,4]
```

-   [객체 리터럴 🔥](#객체-리터럴)

    -   자바스크립트에서 객체란 뭘까요? 👀📚
        -   키와 값으로 구성된 프로퍼티의 집합
    -   함수와 메서드의 차이점에 대해 알고 계신가요? 👀📚
        -   객체의 프로퍼티로 함수도 저장할 수 있다. 이 함수를 메소드라 불린다.
    -   자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?
        -   객체 리터럴, 생성자 함수 사용

```js
const object1 = {}; // 리터럴

const object2 = new Object(); // 생성자 함수
```

-   [원시 값과 객체 비교 🔥](#원시-값과-객체-비교)

    -   동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요? 🔥
        -   데이터가 저장되는 방식이 다르고 이에따라 참조하는 방식이 다르기 때문
    -   값에 의한 전달이 뭔가요? 🔥
        -   값을 새로 복사하는것

```js
let value = 123;

const myFunc = (input) => {
    input += 100;
};

myFunc(value);

// value를 함수로 전달하고 값을 변경하지만 원래 값은 변경되지 않는다.
// input이라는 인자로 복사 되었다.
console.log(value); // 123
```

    -   참조에 의한 전달이 뭔가요? 🔥
        -   값을 새로 복사한것 처럼 보이지만 같은 값을 참조하는것

```js
let value = [1, 2, 3];

const myFunc = (input) => {
    input.push(100);
};

myFunc(value);

// value를 함수로 전달하고 값을 변경하면 원래 배열이 변경된다.
// value와 input은 같은 참조를 가진다.
console.log(value); // [1,2,3,4]
```

-   [함수 🔥](#함수)

    -   자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?
        -   함수 선언문과 함수 표현식이 있다.

```js

const function1 () { ... } // 함수 선언문

const function2 = () => { ... } // 함수 표현식

```

    -   함수 선언문과 함수 표현식은 어떤 차이가 있나요?
        -   함수 선언문은 호이스팅이 발생한다. 선언보다 먼저 접근해도 실행이 가능하다.
        -   함수 표현식도 호이스팅이 발생한다. 단, var,let,const의 호이스팅과 동일하게 발생한다.
    -   즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요 👀📚
        -   정의와 즉시 실행되는 함수

```js
// 이 익명 함수는 선언과 동시에 실행된다.
  (function () {
      ...
  })();

  // 이 함수도 선언과 동시에 실행된다.
  // 함수의 이름이 있지만 다시 호출할 수 없다.
  (function foo() {
      ...
  })();

  foo(); //ReferenceError: foo is not defined
```

-   [스코프 🔥](#스코프)

    -   스코프가 뭔가요? 🔥🔥
        -   변수가 유효한 범위를 말한다.
    -   스코프에는 어떤 종류가 있죠? 🔥
        -   정적 스코프: 함수가 선언되는 시점에 스코프가 결정
        -   동적 스코프: 함수가 호출되는 시점에 스코프가 결정
    -   렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요? 🔥
        -   함수가 선언되는 시점에 스코프가 결정되는것이다.
        -   자바스크립트가 렉시컬 스코프를 따른다.
    -   전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?👀📚
    -   전역 변수를 사용하면 의도하지 않은 문제점이 발생할 가능성이 큰 문제점이 있습니다.
        왜냐하면 전역 변수는 코드 어디서든 참조할 수 있고 할당할 수 있는 유효범위가 넓습니다. (암묵적 결합)
        그리고 전역 변수는 생명 주기도 길기 때문에 오랫동안 변경될 수 있습니다.
        또한 전역 변수를 참조하기 위해서는 스코프체인의 끝에 있기 때문에 검색 속도가 약간 느릴 수 있습니다.
        마지막으로 자바스크립트는 하나의 전역 스코프를 공유하기 때문에 다른 파일에서 동일한 이름의 전역 변수를 사용한다면 예상하지 못한 결과를 얻을 수도 있습니다.

-   [생성자 함수에 의한 객체 생성 🔥](#생성자-함수에-의한-객체-생성)

    -   생성자 함수가 뭔가요? 👀📚
        -   new 키워드와 함께 호출해서 객체를 생성하는 함수
        -   생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.

```js
const obj = new Func1(); // '생성자 함수'에 의해 '인스턴스'가 생성되었다.
```

        -   String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공
        -

    -   객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요? 👀📚
        -   객체 리터럴은 단 하나의 객체만 생성하기 때문에 같은 프로퍼티를 갖는 객체를 여러개 생성할때 비효율적이다. 생성자 함수를 이용하면 구조가 동일한 객체를 간편하게 생성할 수 있다.

```js
const obj11 = {name: 'Kim', age: ''}; // 리터럴: 매번 동일한 객체 구조를 작성해야 한다
const obj12 = {name: 'Lee', age: ''};
const obj13 = {name: 'Park', age: ''};

function Human (name) {
    this.name = name;
    this.age = 0;
}

const obj 21 = new Human('Kim'); // 생성자 함수: 미리 템플릿을 만들어 놓고 더 간편하게 작성한다.
const obj 22 = new Human('Lee');
const obj 23 = new Human('Park');

```

    -   생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요? 👀📚

```js
// 1. 생성자 함수 선언
function Circle(radius) {
    // 3. 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    };
    // 4. 인스턴스 생성시에 생성자 함수를 호출할 때 넣은 인수를 this 바인딩을 통해 프로퍼티에 할당한 뒤, 인스턴스를 반환한다
}
// 2. 인스턴스 생성
const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
```

-   [함수와 일급 객체 🔥](#함수와-일급-객체)

    -   일급 객체가 뭔가요? 👀📚

        -   "일급"이 최상이 계층 뭐 이런뜻이 아니라 다른 요소들과 아무런 차별이 없다는 뜻.(일반 변수처럼 연산, 저장, 함수 전달 인자, 함수 리턴 모두 가능하다는 뜻)
        -   무명의 리터럴로 생성할 수 있다.
        -   변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
        -   함수의 매개변수에 전달할 수 있다.
        -   함수의 반환값으로 사용할 수 있다.

    -   자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요? 👀📚
        -   아래와 같은게 가능하다.

```js
// 일급객체

// 1. 함수를 변수처럼 변수에 할당할 수 있다.
const func1 = () => { ... }

// 2. 함수를 변수처럼 전달인자로 사용이 가능하다 (콜백)
const func2 = (callback) => {
    callback();
}

func2(func1)

// 3. 함수를 변수처럼 리턴값으로 사용이 가능한다.
const func3 = (num) => {
    const func31 = () => {
        return num += 1;
    }

    return func31
}


```

    -   꼬리 질문) 함수형 프로그래밍이 뭔가요? 🔥 👀📚
    -   꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠? 🔥
        - 함수의 결과값이 외부 상태에 의존하지 않고, 부수효과를 발생하지 않는것.

```js
const array = [1, 2, 3];
// 함수가 실행되어도 기존 외부 변수에 영향을 주지 않는다.
const pureFunc = (input) => {
    return input.concat(4);
};

// 함수가 실행되어도 기존 외부 변수가 변경된다.
const normalFunc = (input) => {
    input.push(4);
    return input;
};
```

-   [프로토타입 🔥](#프로토타입)

    -   객체지향 프로그래밍은 무엇을 의미하나요? 🔥 👀📚
        -   프로그램에서 필요한 데이터를 추상화 시켜서 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
        -   명령어나 함수로 이루어진 절차 지향적 관점에서 벗어나 독립적인 단위, 객체의 집합으로 프로그램을 표현하려는것
    -   객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요? 🔥 👀📚
        -   1. 추상화: 객체간 공통적인 특징/기능 추출
        -   2. 상속: 기존 객체의 기능을 다른객체에서 사용할 수 있도록 넘겨주는것
        -   3. 다형성: 부모로부터 받은 메소드를 자식 클래스에서 오버라이딩 되어 사용하는것.
        -   4. 캡슐화: 변수화 함수를 목적에 따라 하나로 묶는 것. 또한 데이터를 함수를 통해서만 접근하도록 하는것
    -   자바스크립트는 객체지향 프로그래밍 언어인가요? 👀📚
        -   자바스크립트는 클래스기반이 아닌 프로토타입기반의 객체지향 프로그래밍
    -   프로토타입이 뭔가요? 👀📚
        -   상속을 구현하기 위해 사용된다.
        -   객체의 원형이라는 의미로 상위객체의 속성을 하위객체에서 접근해서 사용할 수있다.
        -   객체가 만들어지기 위해서 자신을 만드는데 사용한 원형인 프로토타입 객체를 이용해서 생성된다. (자바스크립트는 원시타입을 제외하고 모두 객체)
        -   객체에서 어떤 속성이나 메소드에 접근할때 현재 객체에 없으면 해당객체의 상위 프로토타입에서 접근해서 찾는다. 이를 프로토타입 체인이라고 한다.(스코프 체인과 비슷한듯)

-   [strict mode 🔥](#strict-mode)

    -   strict mode가 뭔가요?
        -   자바스크립트 문법 실수 방지 모드
        -   “use strict” 키워드로 적용 가능
    -   strict mode를 통해 무엇을 예방할 수 있죠?

```js

// 1. 암묵적 전역 방지 window.x 로 등록됨.
x = 20;

// 2. 중복 매개변수 방지
const func1 = (param1, param1) => { ... }

// 3. delete 방지
let a = 1;
delete a;

// 그외 다수

```

-   [빌트인 객체 🔥](#빌트인-객체) 👀📚

    -   빌트인 객체가 뭔가요? 👀📚
        -   자바스크립트에서 기본적으로 제공하는 객체
    -   빌트인 객체의 종류는 어떤게 있죠? 👀📚
        -   Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여개
    -   래퍼 객체에 대해서 알고 있나요? 👀📚
        -   원시 타입을 객체 타입처럼 사용하는 과정 속에서 생기는 임시 객체. 원시 타입인 String, Number, Boolean 으로 특정된다.
        -   원시 값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시 값으로 되돌린다.

```js
let str = "hello"; // str은 원시 타입이다.

console.log(str.length); // 원시 타입에 객체 접근법을 사용하고있다.
// str은 원시타입이지만 객체의 프로퍼티 접근처럼 사용해서 내부 메소드를 사용할 수 있다.
//이때 연관된 String 객체를 생성하고 메소드를 수행한 뒤 다시 원시값으로 되돌린다.
```

-   [this 🔥](#this) 👀📚

    -   this가 뭔가요? 🔥
        -   자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
        -   this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.
    -   this 바인딩이란? 🔥
        -   식별자(변수)와 값을 연결하는 과정
        -   변수 선언은 변수이름(식별자)과 확보된 메모리 공간의 주소를 바인딩하는것
        -   this바인딩은 this와 this가 가리킬 객체를 바인딩하는것
    -   this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

| 함수 호출 방식                                             | this 바인딩                                                            |
| :--------------------------------------------------------- | :--------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체(window/ global)                                              |
| 콜백 함수 호출                                             | 전역 객체(window/ global)                                              |
| 내부 함수 호출                                             | 전역 객체(window/ global)                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                                 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

-   [실행 컨텍스트 🔥](#실행-컨텍스트)

    -   실행 컨텍스트에 대해 말해보세요 🔥🔥
        -   코드가 평가되고 실행되는 환경
        -   자바스크립트는 실행할 코드를 실행 컨텍스트 단위로 메모리 스택에 순서대로 push하고, pop하면서 실행한다.

-   [클로저 🔥](#클로저)

    -   클로저에 대해서 아나요? 🔥🔥
        -   자신이 선언될 당시의 환경을 기억하는 함수
    -   클로저를 사용하면 뭐가 좋죠? 🔥
        -   특정 함수의 지역변수를 외부에서 사용할 수 있다.
        -   private변수처럼 사용할 수 있다.
    -   클로저를 어떻게 생성하나요? 🔥
        -   다음 예시로 설명

```js
const outer = () => {
    let value = 0;
    const inner = () => {
        return (value += 1);
    };
    return inner;
};

const a = outer();

a(); // 1
a(); // 2
a(); // 3
```

-   [클래스 🔥](#클래스) 👀📚

    -   자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?
        -   생성자 함수와 프로토타입을 이용한다.

```js
// ES5 생성자 함수
function Person(name) {
    this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
    console.log("Hi! My name is " + this.name);
};

// 인스턴스 생성
var me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

    -   그럼 생성자 함수와 클래스는 어떤 차이가 있나요?
        -   클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만, 생성자 함수는 일반 함수로 호출된다.
        -   클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 생성자 함수는 해당 키워드를 제공하지 않는다.
        -   클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 작성된 클래스는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
        -   클래스 내의 모든 코드에는 암묵적으로 strict mode가 저장되어 실행되며 strict mode를 해제할 수 없다. <-> 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
    -   클래스 정의
    -   클래스의 상속

```js
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

-   [스프레드 문법 🔥](#스프레드-문법)

    -   spread 문법이 뭔가요?
        -   값을 전개 하는 문법

```js
const a = [1, 2, 3];
console.log(...a); // 1 2 3
```

    -   어떤 상황에서 사용할 수 있죠?
        -   기존 값을 나열해서 리턴할 때 새로운 값을 리턴하기 때문에 배열이나 객체의 깊은 복사에 사용할 수 있다.
        -   혹은 기존 배열/객체 값의 수정, 추가에도 사용 가능하다.

-   [구조 분해 할당 🔥](#구조-분해-할당)

    -   구조 분해 할당이 뭔가요?
        -   값을 해체해서 개별 변수에 담는 것.
    -   구조 분해 할당은 크게 어떤 종류가 있나요?
        -   배열 구조분해할당
        -   객체 구조분해할당

```js
// 배열
const arr = [1, 2, 3];
const [one, two, three] = arr; // one: 1, two: 2, three: 3 이 담긴다.

// 객체
const obj = { name: "Kim", age: 90 };
const { name, age } = obj; // name: name: 'Kim', age: 90 이 담긴다. 단, 변수와 키 값이 동일해야한다.
```

\*uri 와 url 차이, dns 란 무엇인가

-   [브라우저 렌더링 과정 🔥](#브라우저-렌더링-과정) 👀📚
-   참고: https://mystudy.tistory.com/21

        -   브라우저의 렌더링 과정에 대해 설명해보세요 🔥
            -   1. 클라이언트에서 요청한 URI를 DNS를 통해 IP주소로 변환하고, 해당 IP를 가진 서버에 GET요청을 보낸다.
            -   2. 서버에서 응답으로 받은 HTML 데이터를 파싱하고 DOM 트리 생성을 시작한다.
                -   1 브라우저는 서버 응답으로 받은 HTML문서를 2진수 형태로 응답 받는다.
                -   2 이를 HTML마크업 문자열로 변경
                -   3 문자열을 의미를 가진 토큰으로 변환

![토큰화](./HTML%ED%86%A0%ED%81%B0%ED%99%94.png)

            -   4.의미를 가진 토큰을 관계성을 가진 노드로 변환

![토큰화](./HTML%EB%85%B8%EB%93%9C%ED%99%94.png)

            -   노드란 DOM Tree를 구성할수 있는 단위이다.
            -   HTML요소의 집합으로 이루어진 HTML 문서는 부모/자식 관계가 존재하는데 이를 반영해서 트리 자료구조로 구성한다.
            -   이러한 트리 자료구조를 DOM 이라 한다.

![브라우저 렌더링](./%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%ED%8C%8C%EC%8B%B1.png)

        -   3. css마크업을 바탕으로 CSSOM  트리를 생성한다 (바이트 > 문자 > 토큰 > 노드 > CSSOM
        -   4. DOM트리와 CSSOM트리를 결합하여 렌더 트리를 형성한다.
            -   렌더 트리란 DOM과 CSSOM을 합한 후 최종적으로 브라우저에 표기될 것들만 선별되어 생성된다.
            -   이때 display:none 과같이 화면에 나타나지 않을 속성들은 렌더 트리에서 누락된다.
        -   5. 렌더 트리에서 레이아웃을 실행한다. (레이아웃 과정)
            -   렌더 트리를 기반으로 HTML요소의 위치와 크기를 계산한다. %, vh 등은 픽셀로 계산된다.
        -   6. 레이아웃을 통해 얻은 위치에 실제 요소를 그린다.(페인트 과정)
            -
    -   브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
        -   HTML파일 파싱 과정에서 script 태그를 만나면 (별도의 옵션이 없는 한) 파싱을 멈추고 자바스크립트 파일을 해석하고 실행한다.
            -   옵션1. script 태그에 async 속성이 있으면 파싱과 동시에 자바스크립트를 다운로드 하고, 다운로드가 종료되는 즉시 파싱을 멈추고 스크립트를 실행한다.
            -   옵션2. script 태그에 defer 속성이 있으면 async와 동일하게 파싱과 동시에 자바스크립트를 다운로드하지만, HTML 파싱이 종료되고 나서 스크립트를 실행한다.
    -   `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까요?
        - HTML 이 다 구성되지 않은 상태에서 스크립트를 실행하면 존재하지 않는 DOM에 접근하게되어 오류를 발생시킬 수 있기 때문

-   [DOM 🔥](#DOM)

    -   DOM이 뭔가요?
    -   DOM을 구성하는 건 뭐가 있나요?

-   [이벤트 🔥](#이벤트)

    -   마우스 이벤트 타입에는 뭐가 있나요? click 말고 클릭을 대체할 수 있는 이벤트가 있나요?
    -   그 외에 알고 있는 대표적인 이벤트가 있나요?
    -   이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?
    -   이벤트 전파(propagation)에 대해서 알고 있나요?
    -   이벤트 위임(delegation)에 대해서 알고있나요? 🔥
    -   e.preventDefault 에 대해 알고 있나요?
    -   e.stopPropagation

-   [타이머 🔥](#타이머)

    -   호출 스케쥴링이 무엇인가요?
    -   타이머 함수에는 어떤 것들이 있나요?
    -   이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?
    -   디바운스에 대해서 알고 있나요?
    -   쓰로틀에 대해서 알고 있나요?

-   [비동기 프로그래밍 🔥](#비동기-프로그래밍)

    -   동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥

        -   한줄 요약

    -   이벤트 루프와 태스크 큐에 대해서 알고 있나요? 🔥🔥
    -   마이크로태스크 큐에 대해서 알고 있나요? 🔥
    -   태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥

-   [Ajax 🔥](#Ajax)

    -   Ajax가 뭔가요 어떤 것을 담당하고 있죠?
    -   Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?
    -   JSON 이 뭔가요?
    -   JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?
    -   Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?
    -   XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요? 🔥

-   [REST API 🔥](#REST-API)

    -   REST API가 뭔가요?
    -   REST API의 구성은 어떤 것이 있나요?
    -   REST API를 설계하는데 중요한 것이 있을까요?
    -   HTTP 요청 메서드에 대해서 아는대로 얘기해보세요
    -   HTTP 상태 코드를 아는대로 말해주세요 🔥

-   [Promise 🔥](#Promise)

    -   콜백이란 뭐라고 생각하나요? 🔥
    -   프로미스가 뭔가요? 🔥
    -   프로미스 생성 방법
    -   프로미스의 상태를 나타내는 것은 어떤 것들이 있나요? 🔥
    -   프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요? 🔥

-   [제너레이터와 async await 🔥](#제너레이터와-async-await)

    -   제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?
    -   제너레이터의 구조
    -   async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 🔥
    -   Promise와 async/await의 차이점 한 줄 요약 🔥

-   [에러 🔥](#에러)

    -   에러처리를 왜 해야 하나요?
    -   자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?

-   [모듈 🔥](#모듈)

    -   모듈이 뭔가요?
